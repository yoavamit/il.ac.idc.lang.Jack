/*
* generated by Xtext
*/
package il.ac.idc.lang.validation;

import java.util.ArrayList;

import il.ac.idc.lang.jack.*;
import il.ac.idc.lang.util.JackBuiltinLibraries;
import il.ac.idc.lang.util.JackObjectUtil;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class JackJavaValidator extends il.ac.idc.lang.validation.AbstractJackJavaValidator {

    @Check
    public void checkClassName(ClassDef klass) {
        String className = klass.getClassName();
        if (!Character.isUpperCase(className.charAt(0))) {
            warning("Name should start with a capital", JackPackage.Literals.CLASS_DEF__CLASS_NAME);
        }
    }
    
    @Check
    public void checkVariableName(ClassVarDecl varDecl) {
        String varName = varDecl.getVarName();
        if (Character.isUpperCase(varName.charAt(0))) {
            warning("Varaible names should start with a lowercase letter", JackPackage.Literals.CLASS_VAR_DECL__VAR_NAME);
        }
    }
    
    @Check
    public void checkVariableAssignment(LetStatement let) {
        String varName = let.getVarName();
        SubroutineBody function = getContainingSubroutine(let);
        for (VarDecl var : function.getVariables()) {
            if (var.getVarName().equals(varName)) {
                return;
            }
            for ( String addVar : var.getAdditionalVarNames()) {
                if (addVar.equals(varName)) {
                    return;
                }
            }
        }
        
        ClassDef klass = getClassDef(let);
        for(ClassVarDecl var : klass.getVars()) {
            if (var.getVarName().equals(varName)) {
                return;
            }
        }
        error("Varaible " + varName + " wasn't initialized", JackPackage.Literals.LET_STATEMENT__VAR_NAME);
    }
    
    @Check
    public void checkFunctionCall(SubroutineCall call) {
        String obj = call.getVarOrClass();
        String name = call.getName();
        if (obj == null) {
            // handle same scope calls
            if (!JackBuiltinLibraries.isFunction(name) && !getClassSubroutines(call).contains(name)) {
                error("Subroutine " + name + " is undefined", JackPackage.Literals.SUBROUTINE_CALL__NAME);
            }
        } else if (JackBuiltinLibraries.isLibrary(obj)) {
            // handle static calls
            if (!JackBuiltinLibraries.isFunction(obj, name)) {
                error("Subroutine " + obj + "." + name + " is undefined", JackPackage.Literals.SUBROUTINE_CALL__NAME);
            }
        }
    }
    
    private ClassDef getClassDef(EObject obj) {
        EObject parent = obj.eContainer();
        while (parent != null) {
            if (parent instanceof ClassDef)
                return (ClassDef) parent;
            parent = parent.eContainer();
        }
        return null;
    }
    
    private ArrayList<String> getClassSubroutines(EObject obj) {
        Jack root = JackObjectUtil.getRoot(obj);
        ArrayList<String> subroutines = new ArrayList<String>();
        for(SubroutineDecl sub : root.getRoot().getRoutines()) {
            subroutines.add(sub.getSubroutineName());
        }
        
        return subroutines;
    }
    
    private SubroutineBody getContainingSubroutine(EObject obj) {
        EObject parent = obj.eContainer();
        while (parent != null) {
            if (parent instanceof SubroutineBody) {
                return (SubroutineBody) parent;
            }
            parent = parent.eContainer();
        }
        return null;
    }
}
